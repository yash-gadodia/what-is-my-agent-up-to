<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="refresh" content="15" />
  <title>Pitch Prep Notes</title>
  <style>
    :root {
      --bg: #f3f6fb;
      --panel: #ffffff;
      --ink: #182230;
      --muted: #5d6b7b;
      --line: #d8e1ec;
      --accent: #005bd1;
      --accent-soft: #eaf2ff;
      --mono-bg: #eef3f9;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 8% 10%, #ffffff, var(--bg));
      color: var(--ink);
      font-family: "Segoe UI", "SF Pro Text", "Avenir Next", sans-serif;
      line-height: 1.55;
      font-size: 18px;
      padding: 28px 16px 80px;
    }
    .wrap {
      max-width: 960px;
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 28px 30px 34px;
      box-shadow: 0 10px 30px rgba(20, 42, 80, 0.08);
    }
    h1, h2, h3 { margin: 0; line-height: 1.25; }
    h1 { font-size: 2rem; margin-bottom: 16px; }
    h2 {
      font-size: 1.32rem;
      margin-top: 24px;
      margin-bottom: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }
    h3 { font-size: 1.05rem; margin-top: 16px; margin-bottom: 8px; color: var(--accent); }
    p { margin: 7px 0 9px; color: var(--ink); }
    ul, ol { margin: 4px 0 12px 24px; padding: 0; }
    li { margin: 5px 0; }
    code {
      background: var(--mono-bg);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 1px 6px;
      font-size: 0.92em;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
    }
    strong { color: #0f1f35; }
    .banner {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 18px;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--accent-soft);
      border: 1px solid #cde0ff;
      color: #0f3678;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      body { font-size: 16px; padding: 12px 8px 42px; }
      .wrap { padding: 16px 14px 22px; border-radius: 12px; }
      h1 { font-size: 1.42rem; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <div class="banner">
      <span>This page auto-refreshes every 15s.</span>
      <span>Source: <code>docs/PITCH-PREP.md</code></span>
    </div>
<h1>Pitch Prep Notes (Auto-Generated)</h1>
<p>Last updated: 2026-02-28T08:12:26.569Z</p>
<p>This file is generated by <code>scripts/update-pitch-prep.mjs</code>.</p>
<p>Regenerate with:</p>
<p><code>npm run pitch:prep</code></p>
<p>Continuous auto-refresh (every 30s default):</p>
<p><code>npm run pitch:prep:watch</code></p>
<p>Strict pre-judge refresh (runs tests too):</p>
<p><code>npm run pitch:prep:verify</code></p>
<h2>0) Judge Criteria (from briefing)</h2>
<ol>
<li>Clarity of idea</li>
<li>Technical execution</li>
<li>Completeness</li>
<li>Impact and insight</li>
<li>Use of Codex</li>
</ol>
<h2>1) Core Pitch (Say This Early)</h2>
<p>WIMUT is a live observability dashboard for Codex runs. In under 5 seconds, it tells you what the agent is doing now, whether progress is healthy, and what intervention to take if it is stuck.</p>
<h2>2) 2-Minute Video Script (Say + Show + Proves)</h2>
<h3>0:00-0:15 Problem + Value</h3>
<ul>
<li>Say: &quot;Agent runs are powerful but hard to read live. We built WIMUT so operators can understand runtime state and intervene confidently.&quot;</li>
<li>Show: Dashboard landing with active lanes and top summary bar.</li>
<li>Proves: Clarity of idea.</li>
</ul>
<h3>0:15-0:35 Live Codex Ingestion</h3>
<ul>
<li>Say: &quot;This is not a mock feed. We ingest real Codex app-server notifications through our relay.&quot;</li>
<li>Show: Connected status + live lane updates while relay is running.</li>
<li>Proves: Use of Codex, technical execution.</li>
</ul>
<h3>0:35-0:55 Traceability (Raw -&gt; Derived)</h3>
<ul>
<li>Say: &quot;Every visual change is traceable. Here is the raw event, and here is the derived operational meaning.&quot;</li>
<li>Show: Open one timeline event and inspect raw payload + mapped meaning side by side.</li>
<li>Proves: Technical execution, runtime traceability.</li>
</ul>
<h3>0:55-1:20 Operator Insight</h3>
<ul>
<li>Say: &quot;We do not just display telemetry. We compute stuck risk and propose the next operator action.&quot;</li>
<li>Show: Scorecard, stuck signal, and intervention text for one agent/run.</li>
<li>Proves: Impact and insight.</li>
</ul>
<h3>1:20-1:40 Completeness + Reliability</h3>
<ul>
<li>Say: &quot;The full workflow is covered: live mode, inspector, scorecard, replay, and simulator fallback for deterministic demos.&quot;</li>
<li>Show: Quick switch to replay or simulator controls in Ops drawer, then back.</li>
<li>Proves: Completeness and demo reliability.</li>
</ul>
<h3>1:40-2:00 Close</h3>
<ul>
<li>Say: &quot;WIMUT turns agent activity into operational clarity: faster understanding, safer interventions, and higher trust in Codex-driven workflows.&quot;</li>
<li>Show: Return to live view with multiple active lanes and status chips.</li>
<li>Proves: Clarity, impact, and use of Codex.</li>
</ul>
<h2>3) Criteria Coverage Checklist (Before Recording)</h2>
<ol>
<li>Clarity of idea: one-sentence problem/value stated in first 15s.</li>
<li>Technical execution: relay/app-server path mentioned and visible.</li>
<li>Completeness: live + inspector + scorecard + replay/simulator touched.</li>
<li>Impact and insight: stuck score and intervention recommendation shown.</li>
<li>Use of Codex: explicitly state source is Codex app-server events.</li>
</ol>
<h2>4) 2-Minute Talking Points Cheat Sheet</h2>
<h3>Product Points To Cover</h3>
<ul>
<li>Problem: live agent runs are hard to parse quickly under pressure.</li>
<li>User value: gives instant answer to &quot;what is happening now?&quot;</li>
<li>Decision support: highlights stuck risk and suggests intervention.</li>
<li>Trust: raw event inspector keeps the system explainable.</li>
<li>Reliability: replay/simulator keeps demo flow stable if live stream degrades.</li>
</ul>
<h3>Technical Points To Cover</h3>
<ul>
<li>Ingestion path: Codex app-server notifications relayed over websocket.</li>
<li>Protocol rigor: initialize -&gt; thread/start -&gt; turn/start lifecycle.</li>
<li>Mapping layer: raw events normalized into stable derived signals.</li>
<li>Runtime signals: tool activity, file changes, errors/success, stuck score.</li>
<li>Fallback architecture: live + replay + simulator + swarm for resilience.</li>
</ul>
<h2>5) Criteria Mapping Talking Points</h2>
<h3>4.1 Clarity of idea</h3>
<ul>
<li>The city/lane view answers &quot;what is happening now&quot; at a glance.</li>
<li>Story and score surfaces reduce interpretation time during live runs.</li>
</ul>
<h3>4.2 Technical execution</h3>
<ul>
<li>Relay harness uses Codex app-server protocol path (initialize -&gt; thread/start -&gt; turn/start).</li>
<li>Frontend keeps raw-event visibility and explicit derived mapping logic.</li>
</ul>
<h3>4.3 Completeness</h3>
<ul>
<li>Live mode, replay path, simulator fallback, timeline, inspector, and intervention scorecard are all available.</li>
<li>Swarm mode supports multi-agent stress scenarios for local reliability checks.</li>
</ul>
<h3>4.4 Impact and insight</h3>
<ul>
<li>Stuck scoring identifies unhealthy loops/inactivity.</li>
<li>Intervention text converts telemetry into concrete operator action.</li>
</ul>
<h3>4.5 Use of Codex</h3>
<ul>
<li>Primary source is live Codex app-server notifications, not synthetic-only events.</li>
<li>Raw payload remains inspectable to preserve trust and debugging value.</li>
</ul>
<h2>6) Runtime Readiness Snapshot</h2>
<ul>
<li>Branch: main</li>
<li>Commit: c2e984b</li>
<li>Working tree changed files: 2</li>
<li>Node: v24.10.0</li>
<li>npm: 11.6.0</li>
<li>Test status from this refresh: not run (use --verify for strict pre-judge refresh)</li>
</ul>
<ul>
<li>Live relay script present: yes</li>
<li>Swarm fallback script present: yes</li>
<li>Helper script present: yes</li>
<li>Replay mentioned in runtime docs: yes</li>
<li>Simulator mentioned in runtime docs: yes</li>
<li>Raw inspector path mentioned: yes</li>
<li>Scorecard path mentioned: yes</li>
<li>Stuck detection path mentioned: yes</li>
</ul>
<h2>7) Judge Questions You Should Pre-Answer</h2>
<ol>
<li>Why does this need to exist if logs already exist?</li>
</ol>
<ul>
<li>Logs show data, WIMUT shows operational state + intervention path in real time.</li>
</ul>
<ol>
<li>How do you avoid being &quot;just another dashboard&quot;?</li>
</ol>
<ul>
<li>We keep traceability from raw Codex events to derived insights and prioritize operator decisions over vanity charts.</li>
</ul>
<ol>
<li>What happens if live ingestion fails during demo?</li>
</ol>
<ul>
<li>We fail fast visibly, then switch to replay/simulator for deterministic narrative continuity.</li>
</ul>
<ol>
<li>What is technically hard here?</li>
</ol>
<ul>
<li>Stable event normalization under noisy runtime streams while preserving raw inspectability.</li>
</ul>
<ol>
<li>What is the measurable impact?</li>
</ol>
<ul>
<li>Lower time-to-understand and faster intervention when runs stall, error, or require approval.</li>
</ul>
<h2>8) Final 10-Minute Pre-Judging Checklist</h2>
<ol>
<li>Run: <code>npm run pitch:prep:verify</code></li>
<li>Start UI: <code>npm run dev</code></li>
<li>Start relay: <code>npm run relay -- --repo /abs/path --prompt &quot;Run tests and fix first failure&quot;</code></li>
<li>Optional helper: <code>npm run helper</code></li>
<li>Open UI and validate: websocket connected, timeline events flowing, scorecard changing</li>
<li>Keep swarm fallback command ready: <code>npm run swarm -- --repo /abs/path --count 4 --port 8899 --continuous true</code></li>
<li>Rehearse one clean sentence per judging criterion</li>
</ol>
<h2>9) Red-Flag Avoidance (During Pitch)</h2>
<ul>
<li>Do not start with simulator if live is healthy; show Codex path first.</li>
<li>Do not hide raw events; inspectors increase trust with judges.</li>
<li>Do not over-focus visuals; always tie back to intervention decisions.</li>
<li>If stream noise rises, explicitly narrate fallback switch instead of silently changing modes.</li>
</ul>
  </main>
</body>
</html>
