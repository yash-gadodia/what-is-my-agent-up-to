#!/usr/bin/env node
import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync } from 'node:fs';
import path from 'node:path';
import process from 'node:process';

const args = process.argv.slice(2);
const watchMode = args.includes('--watch');
const verifyMode = args.includes('--verify');
const intervalArgIndex = args.indexOf('--interval');
const intervalSeconds = intervalArgIndex >= 0 ? Number(args[intervalArgIndex + 1]) : 30;
const safeIntervalSeconds = Number.isFinite(intervalSeconds) && intervalSeconds > 0 ? intervalSeconds : 30;

const root = process.cwd();
const outputPath = path.join(root, 'docs', 'PITCH-PREP.md');
const outputHtmlPath = path.join(root, 'docs', 'PITCH-PREP.html');
const readmePath = path.join(root, 'README.md');
const packagePath = path.join(root, 'package.json');

function run(cmd) {
  try {
    return execSync(cmd, {
      cwd: root,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'pipe']
    }).trim();
  } catch {
    return 'n/a';
  }
}

function yesNo(value) {
  return value ? 'yes' : 'no';
}

function getFeaturePresence(readme) {
  const checks = {
    liveMode: /live Codex app-server notifications/i.test(readme),
    replay: /replay/i.test(readme),
    simulator: /simulator/i.test(readme),
    inspector: /inspector/i.test(readme),
    scorecard: /scorecard/i.test(readme),
    stuckDetection: /stuck detection/i.test(readme),
    swarm: /swarm/i.test(readme)
  };

  return checks;
}

function getQuickStatus() {
  const branch = run('git rev-parse --abbrev-ref HEAD');
  const commit = run('git rev-parse --short HEAD');
  const changedFilesRaw = run('git status --porcelain');
  const changedCount = changedFilesRaw === 'n/a' || changedFilesRaw === ''
    ? 0
    : changedFilesRaw.split('\n').filter(Boolean).length;
  const nodeVersion = run('node -v');
  const npmVersion = run('npm -v');

  let tests = 'not run';
  if (verifyMode) {
    try {
      execSync('npm test', { cwd: root, stdio: 'pipe' });
      tests = 'pass';
    } catch {
      tests = 'fail';
    }
  }

  return {
    branch,
    commit,
    changedCount,
    nodeVersion,
    npmVersion,
    tests
  };
}

function buildMarkdown() {
  const now = new Date();
  const updatedAt = now.toISOString();
  const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));
  const readme = readFileSync(readmePath, 'utf8');

  const scripts = packageJson.scripts || {};
  const hasRelay = Boolean(scripts.relay);
  const hasSwarm = Boolean(scripts.swarm);
  const hasHelper = Boolean(scripts.helper);

  const features = getFeaturePresence(readme);
  const status = getQuickStatus();

  const readinessSummary = [
    `- Live relay script present: ${yesNo(hasRelay)}`,
    `- Swarm fallback script present: ${yesNo(hasSwarm)}`,
    `- Helper script present: ${yesNo(hasHelper)}`,
    `- Replay mentioned in runtime docs: ${yesNo(features.replay)}`,
    `- Simulator mentioned in runtime docs: ${yesNo(features.simulator)}`,
    `- Raw inspector path mentioned: ${yesNo(features.inspector)}`,
    `- Scorecard path mentioned: ${yesNo(features.scorecard)}`,
    `- Stuck detection path mentioned: ${yesNo(features.stuckDetection)}`
  ].join('\n');

  const verificationNote = verifyMode
    ? `- Test status from this refresh: ${status.tests}`
    : '- Test status from this refresh: not run (use --verify for strict pre-judge refresh)';

  return `# Pitch Prep Notes (Auto-Generated)

Last updated: ${updatedAt}

This file is generated by \`scripts/update-pitch-prep.mjs\`.
Regenerate with:

\`npm run pitch:prep\`

Continuous auto-refresh (every ${safeIntervalSeconds}s default):

\`npm run pitch:prep:watch\`

Strict pre-judge refresh (runs tests too):

\`npm run pitch:prep:verify\`

## 0) Judge Criteria (from briefing)

1. Clarity of idea
2. Technical execution
3. Completeness
4. Impact and insight
5. Use of Codex

## 1) Core Pitch (Say This Early)

WIMUT is a live observability dashboard for Codex runs. In under 5 seconds, it tells you what the agent is doing now, whether progress is healthy, and what intervention to take if it is stuck.

## 2) 2-Minute Video Script (Say + Show + Proves)

### 0:00-0:15 Problem + Value

- Say: "Agent runs are powerful but hard to read live. We built WIMUT so operators can understand runtime state and intervene confidently."
- Show: Dashboard landing with active lanes and top summary bar.
- Proves: Clarity of idea.

### 0:15-0:35 Live Codex Ingestion

- Say: "This is not a mock feed. We ingest real Codex app-server notifications through our relay."
- Show: Connected status + live lane updates while relay is running.
- Proves: Use of Codex, technical execution.

### 0:35-0:55 Traceability (Raw -> Derived)

- Say: "Every visual change is traceable. Here is the raw event, and here is the derived operational meaning."
- Show: Open one timeline event and inspect raw payload + mapped meaning side by side.
- Proves: Technical execution, runtime traceability.

### 0:55-1:20 Operator Insight

- Say: "We do not just display telemetry. We compute stuck risk and propose the next operator action."
- Show: Scorecard, stuck signal, and intervention text for one agent/run.
- Proves: Impact and insight.

### 1:20-1:40 Completeness + Reliability

- Say: "The full workflow is covered: live mode, inspector, scorecard, replay, and simulator fallback for deterministic demos."
- Show: Quick switch to replay or simulator controls in Ops drawer, then back.
- Proves: Completeness and demo reliability.

### 1:40-2:00 Close

- Say: "WIMUT turns agent activity into operational clarity: faster understanding, safer interventions, and higher trust in Codex-driven workflows."
- Show: Return to live view with multiple active lanes and status chips.
- Proves: Clarity, impact, and use of Codex.

## 3) Criteria Coverage Checklist (Before Recording)

1. Clarity of idea: one-sentence problem/value stated in first 15s.
2. Technical execution: relay/app-server path mentioned and visible.
3. Completeness: live + inspector + scorecard + replay/simulator touched.
4. Impact and insight: stuck score and intervention recommendation shown.
5. Use of Codex: explicitly state source is Codex app-server events.

## 4) 2-Minute Talking Points Cheat Sheet

### Product Points To Cover

- Problem: live agent runs are hard to parse quickly under pressure.
- User value: gives instant answer to "what is happening now?"
- Decision support: highlights stuck risk and suggests intervention.
- Trust: raw event inspector keeps the system explainable.
- Reliability: replay/simulator keeps demo flow stable if live stream degrades.

### Technical Points To Cover

- Ingestion path: Codex app-server notifications relayed over websocket.
- Protocol rigor: initialize -> thread/start -> turn/start lifecycle.
- Mapping layer: raw events normalized into stable derived signals.
- Runtime signals: tool activity, file changes, errors/success, stuck score.
- Fallback architecture: live + replay + simulator + swarm for resilience.

## 5) Criteria Mapping Talking Points

### 4.1 Clarity of idea

- The city/lane view answers "what is happening now" at a glance.
- Story and score surfaces reduce interpretation time during live runs.

### 4.2 Technical execution

- Relay harness uses Codex app-server protocol path (initialize -> thread/start -> turn/start).
- Frontend keeps raw-event visibility and explicit derived mapping logic.

### 4.3 Completeness

- Live mode, replay path, simulator fallback, timeline, inspector, and intervention scorecard are all available.
- Swarm mode supports multi-agent stress scenarios for local reliability checks.

### 4.4 Impact and insight

- Stuck scoring identifies unhealthy loops/inactivity.
- Intervention text converts telemetry into concrete operator action.

### 4.5 Use of Codex

- Primary source is live Codex app-server notifications, not synthetic-only events.
- Raw payload remains inspectable to preserve trust and debugging value.

## 6) Runtime Readiness Snapshot

- Branch: ${status.branch}
- Commit: ${status.commit}
- Working tree changed files: ${status.changedCount}
- Node: ${status.nodeVersion}
- npm: ${status.npmVersion}
${verificationNote}

${readinessSummary}

## 7) Judge Questions You Should Pre-Answer

1. Why does this need to exist if logs already exist?
- Logs show data, WIMUT shows operational state + intervention path in real time.

2. How do you avoid being "just another dashboard"?
- We keep traceability from raw Codex events to derived insights and prioritize operator decisions over vanity charts.

3. What happens if live ingestion fails during demo?
- We fail fast visibly, then switch to replay/simulator for deterministic narrative continuity.

4. What is technically hard here?
- Stable event normalization under noisy runtime streams while preserving raw inspectability.

5. What is the measurable impact?
- Lower time-to-understand and faster intervention when runs stall, error, or require approval.

## 8) Final 10-Minute Pre-Judging Checklist

1. Run: \`npm run pitch:prep:verify\`
2. Start UI: \`npm run dev\`
3. Start relay: \`npm run relay -- --repo /abs/path --prompt "Run tests and fix first failure"\`
4. Optional helper: \`npm run helper\`
5. Open UI and validate: websocket connected, timeline events flowing, scorecard changing
6. Keep swarm fallback command ready: \`npm run swarm -- --repo /abs/path --count 4 --port 8899 --continuous true\`
7. Rehearse one clean sentence per judging criterion

## 9) Red-Flag Avoidance (During Pitch)

- Do not start with simulator if live is healthy; show Codex path first.
- Do not hide raw events; inspectors increase trust with judges.
- Do not over-focus visuals; always tie back to intervention decisions.
- If stream noise rises, explicitly narrate fallback switch instead of silently changing modes.
`;
}

function escapeHtml(value) {
  return value
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function inlineMarkdownToHtml(value) {
  const escaped = escapeHtml(value);
  return escaped
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
}

function markdownToHtml(markdown) {
  const lines = markdown.split('\n');
  const chunks = [];
  let inUnorderedList = false;
  let inOrderedList = false;

  function closeLists() {
    if (inUnorderedList) {
      chunks.push('</ul>');
      inUnorderedList = false;
    }
    if (inOrderedList) {
      chunks.push('</ol>');
      inOrderedList = false;
    }
  }

  for (const line of lines) {
    if (line.startsWith('### ')) {
      closeLists();
      chunks.push(`<h3>${inlineMarkdownToHtml(line.slice(4))}</h3>`);
      continue;
    }
    if (line.startsWith('## ')) {
      closeLists();
      chunks.push(`<h2>${inlineMarkdownToHtml(line.slice(3))}</h2>`);
      continue;
    }
    if (line.startsWith('# ')) {
      closeLists();
      chunks.push(`<h1>${inlineMarkdownToHtml(line.slice(2))}</h1>`);
      continue;
    }
    if (/^\d+\.\s+/.test(line)) {
      if (!inOrderedList) {
        closeLists();
        chunks.push('<ol>');
        inOrderedList = true;
      }
      chunks.push(`<li>${inlineMarkdownToHtml(line.replace(/^\d+\.\s+/, ''))}</li>`);
      continue;
    }
    if (line.startsWith('- ')) {
      if (!inUnorderedList) {
        closeLists();
        chunks.push('<ul>');
        inUnorderedList = true;
      }
      chunks.push(`<li>${inlineMarkdownToHtml(line.slice(2))}</li>`);
      continue;
    }
    if (line.trim() === '') {
      closeLists();
      continue;
    }

    closeLists();
    chunks.push(`<p>${inlineMarkdownToHtml(line)}</p>`);
  }

  closeLists();
  return chunks.join('\n');
}

function buildHtml(markdown) {
  const body = markdownToHtml(markdown);
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="refresh" content="15" />
  <title>Pitch Prep Notes</title>
  <style>
    :root {
      --bg: #f3f6fb;
      --panel: #ffffff;
      --ink: #182230;
      --muted: #5d6b7b;
      --line: #d8e1ec;
      --accent: #005bd1;
      --accent-soft: #eaf2ff;
      --mono-bg: #eef3f9;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 8% 10%, #ffffff, var(--bg));
      color: var(--ink);
      font-family: "Segoe UI", "SF Pro Text", "Avenir Next", sans-serif;
      line-height: 1.55;
      font-size: 18px;
      padding: 28px 16px 80px;
    }
    .wrap {
      max-width: 960px;
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 28px 30px 34px;
      box-shadow: 0 10px 30px rgba(20, 42, 80, 0.08);
    }
    h1, h2, h3 { margin: 0; line-height: 1.25; }
    h1 { font-size: 2rem; margin-bottom: 16px; }
    h2 {
      font-size: 1.32rem;
      margin-top: 24px;
      margin-bottom: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }
    h3 { font-size: 1.05rem; margin-top: 16px; margin-bottom: 8px; color: var(--accent); }
    p { margin: 7px 0 9px; color: var(--ink); }
    ul, ol { margin: 4px 0 12px 24px; padding: 0; }
    li { margin: 5px 0; }
    code {
      background: var(--mono-bg);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 1px 6px;
      font-size: 0.92em;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
    }
    strong { color: #0f1f35; }
    .banner {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 18px;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--accent-soft);
      border: 1px solid #cde0ff;
      color: #0f3678;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      body { font-size: 16px; padding: 12px 8px 42px; }
      .wrap { padding: 16px 14px 22px; border-radius: 12px; }
      h1 { font-size: 1.42rem; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <div class="banner">
      <span>This page auto-refreshes every 15s.</span>
      <span>Source: <code>docs/PITCH-PREP.md</code></span>
    </div>
${body}
  </main>
</body>
</html>
`;
}

function writePitchDoc() {
  const markdown = buildMarkdown();
  const html = buildHtml(markdown);
  const previous = (() => {
    try {
      return readFileSync(outputPath, 'utf8');
    } catch {
      return '';
    }
  })();
  const previousHtml = (() => {
    try {
      return readFileSync(outputHtmlPath, 'utf8');
    } catch {
      return '';
    }
  })();

  if (markdown !== previous) {
    writeFileSync(outputPath, markdown, 'utf8');
    process.stdout.write(`[pitch-prep] updated ${outputPath}\n`);
  }
  if (html !== previousHtml) {
    writeFileSync(outputHtmlPath, html, 'utf8');
    process.stdout.write(`[pitch-prep] updated ${outputHtmlPath}\n`);
  }
  if (markdown === previous && html === previousHtml) {
    process.stdout.write('[pitch-prep] no changes\n');
  } else {
    process.stdout.write('[pitch-prep] refreshed output files\n');
  }
}

writePitchDoc();

if (watchMode) {
  process.stdout.write(`[pitch-prep] watching every ${safeIntervalSeconds}s\n`);
  setInterval(() => {
    writePitchDoc();
  }, safeIntervalSeconds * 1000);
}
