#!/usr/bin/env node
import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync } from 'node:fs';
import path from 'node:path';
import process from 'node:process';

const args = process.argv.slice(2);
const watchMode = args.includes('--watch');
const verifyMode = args.includes('--verify');
const intervalArgIndex = args.indexOf('--interval');
const intervalSeconds = intervalArgIndex >= 0 ? Number(args[intervalArgIndex + 1]) : 30;
const safeIntervalSeconds = Number.isFinite(intervalSeconds) && intervalSeconds > 0 ? intervalSeconds : 30;

const root = process.cwd();
const outputPath = path.join(root, 'docs', 'PITCH-PREP.md');
const outputHtmlPath = path.join(root, 'docs', 'PITCH-PREP.html');
const readmePath = path.join(root, 'README.md');
const packagePath = path.join(root, 'package.json');

function run(cmd) {
  try {
    return execSync(cmd, {
      cwd: root,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'pipe']
    }).trim();
  } catch {
    return 'n/a';
  }
}

function yesNo(value) {
  return value ? 'yes' : 'no';
}

function getFeaturePresence(readme) {
  const checks = {
    liveMode: /live Codex app-server notifications/i.test(readme),
    replay: /replay/i.test(readme),
    simulator: /simulator/i.test(readme),
    inspector: /inspector/i.test(readme),
    scorecard: /scorecard/i.test(readme),
    stuckDetection: /stuck detection/i.test(readme),
    swarm: /swarm/i.test(readme)
  };

  return checks;
}

function getQuickStatus() {
  const branch = run('git rev-parse --abbrev-ref HEAD');
  const commit = run('git rev-parse --short HEAD');
  const changedFilesRaw = run('git status --porcelain');
  const changedCount = changedFilesRaw === 'n/a' || changedFilesRaw === ''
    ? 0
    : changedFilesRaw.split('\n').filter(Boolean).length;
  const nodeVersion = run('node -v');
  const npmVersion = run('npm -v');

  let tests = 'not run';
  if (verifyMode) {
    try {
      execSync('npm test', { cwd: root, stdio: 'pipe' });
      tests = 'pass';
    } catch {
      tests = 'fail';
    }
  }

  return {
    branch,
    commit,
    changedCount,
    nodeVersion,
    npmVersion,
    tests
  };
}

function buildMarkdown() {
  const now = new Date();
  const updatedAt = now.toISOString();
  const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));
  const readme = readFileSync(readmePath, 'utf8');

  const scripts = packageJson.scripts || {};
  const hasRelay = Boolean(scripts.relay);
  const hasSwarm = Boolean(scripts.swarm);
  const hasHelper = Boolean(scripts.helper);

  const features = getFeaturePresence(readme);
  const status = getQuickStatus();

  const readinessSummary = [
    `- Live relay script present: ${yesNo(hasRelay)}`,
    `- Swarm fallback script present: ${yesNo(hasSwarm)}`,
    `- Helper script present: ${yesNo(hasHelper)}`,
    `- Replay mentioned in runtime docs: ${yesNo(features.replay)}`,
    `- Simulator mentioned in runtime docs: ${yesNo(features.simulator)}`,
    `- Raw inspector path mentioned: ${yesNo(features.inspector)}`,
    `- Scorecard path mentioned: ${yesNo(features.scorecard)}`,
    `- Stuck detection path mentioned: ${yesNo(features.stuckDetection)}`
  ].join('\n');

  const verificationNote = verifyMode
    ? `- Test status from this refresh: ${status.tests}`
    : '- Test status from this refresh: not run (use --verify for strict pre-judge refresh)';

  return `# Pitch Prep Notes (Auto-Generated)\n\nLast updated: ${updatedAt}\n\nThis file is generated by \`scripts/update-pitch-prep.mjs\`.\nRegenerate with:\n\n\`npm run pitch:prep\`\n\nContinuous auto-refresh (every ${safeIntervalSeconds}s default):\n\n\`npm run pitch:prep:watch\`\n\nStrict pre-judge refresh (runs tests too):\n\n\`npm run pitch:prep:verify\`\n\n## 0) Judge Criteria (from briefing)\n\n1. Clarity of idea\n2. Technical execution\n3. Completeness\n4. Impact and insight\n5. Use of Codex\n\n## 1) One-Line Pitch\n\nWIMUT is a live observability dashboard for Codex runs that makes agent behavior legible in seconds and gives operators clear intervention decisions.\n\n## 2) 2-Minute Demo Script\n\n1. Open the dashboard and state the problem in one sentence: agent runs are noisy and hard to intervene in confidently.\n2. Show live connection status + run lanes to establish this is runtime, not a static mock.\n3. Trigger/observe activity and explain mapping from raw events to derived signals (tool activity, file changes, error/success).\n4. Open one timeline item and compare raw payload vs derived meaning to prove traceability.\n5. Show scorecard + stuck signal and read intervention suggestion out loud.\n6. Switch to replay/simulator only if live stream gets noisy, while preserving the same operational narrative.\n7. Close with impact: faster understanding, safer intervention, more trustworthy agent operations.\n\n## 3) Criteria Mapping Talking Points\n\n### 3.1 Clarity of idea\n\n- The city/lane view answers \"what is happening now\" at a glance.\n- Story and score surfaces reduce interpretation time during live runs.\n\n### 3.2 Technical execution\n\n- Relay harness uses Codex app-server protocol path (initialize -> thread/start -> turn/start).\n- Frontend keeps raw-event visibility and explicit derived mapping logic.\n\n### 3.3 Completeness\n\n- Live mode, replay path, simulator fallback, timeline, inspector, and intervention scorecard are all available.\n- Swarm mode supports multi-agent stress scenarios for local reliability checks.\n\n### 3.4 Impact and insight\n\n- Stuck scoring identifies unhealthy loops/inactivity.\n- Intervention text converts telemetry into concrete operator action.\n\n### 3.5 Use of Codex\n\n- Primary source is live Codex app-server notifications, not synthetic-only events.\n- Raw payload remains inspectable to preserve trust and debugging value.\n\n## 4) Runtime Readiness Snapshot\n\n- Branch: ${status.branch}\n- Commit: ${status.commit}\n- Working tree changed files: ${status.changedCount}\n- Node: ${status.nodeVersion}\n- npm: ${status.npmVersion}\n${verificationNote}\n\n${readinessSummary}\n\n## 5) Judge Questions You Should Pre-Answer\n\n1. Why does this need to exist if logs already exist?\n- Logs show data, WIMUT shows operational state + intervention path in real time.\n\n2. How do you avoid being \"just another dashboard\"?\n- We keep traceability from raw Codex events to derived insights and prioritize operator decisions over vanity charts.\n\n3. What happens if live ingestion fails during demo?\n- We fail fast visibly, then switch to replay/simulator for deterministic narrative continuity.\n\n4. What is technically hard here?\n- Stable event normalization under noisy runtime streams while preserving raw inspectability.\n\n5. What is the measurable impact?\n- Lower time-to-understand and faster intervention when runs stall, error, or require approval.\n\n## 6) Final 10-Minute Pre-Judging Checklist\n\n1. Run: \`npm run pitch:prep:verify\`\n2. Start UI: \`npm run dev\`\n3. Start relay: \`npm run relay -- --repo /abs/path --prompt \"Run tests and fix first failure\"\`\n4. Optional helper: \`npm run helper\`\n5. Open UI and validate: websocket connected, timeline events flowing, scorecard changing\n6. Keep swarm fallback command ready: \`npm run swarm -- --repo /abs/path --count 4 --port 8899 --continuous true\`\n7. Rehearse one clean sentence per judging criterion\n\n## 7) Red-Flag Avoidance (During Pitch)\n\n- Do not start with simulator if live is healthy; show Codex path first.\n- Do not hide raw events; inspectors increase trust with judges.\n- Do not over-focus visuals; always tie back to intervention decisions.\n- If stream noise rises, explicitly narrate fallback switch instead of silently changing modes.\n`;
}

function escapeHtml(value) {
  return value
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function inlineMarkdownToHtml(value) {
  const escaped = escapeHtml(value);
  return escaped
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
}

function markdownToHtml(markdown) {
  const lines = markdown.split('\n');
  const chunks = [];
  let inUnorderedList = false;
  let inOrderedList = false;

  function closeLists() {
    if (inUnorderedList) {
      chunks.push('</ul>');
      inUnorderedList = false;
    }
    if (inOrderedList) {
      chunks.push('</ol>');
      inOrderedList = false;
    }
  }

  for (const line of lines) {
    if (line.startsWith('### ')) {
      closeLists();
      chunks.push(`<h3>${inlineMarkdownToHtml(line.slice(4))}</h3>`);
      continue;
    }
    if (line.startsWith('## ')) {
      closeLists();
      chunks.push(`<h2>${inlineMarkdownToHtml(line.slice(3))}</h2>`);
      continue;
    }
    if (line.startsWith('# ')) {
      closeLists();
      chunks.push(`<h1>${inlineMarkdownToHtml(line.slice(2))}</h1>`);
      continue;
    }
    if (/^\d+\.\s+/.test(line)) {
      if (!inOrderedList) {
        closeLists();
        chunks.push('<ol>');
        inOrderedList = true;
      }
      chunks.push(`<li>${inlineMarkdownToHtml(line.replace(/^\d+\.\s+/, ''))}</li>`);
      continue;
    }
    if (line.startsWith('- ')) {
      if (!inUnorderedList) {
        closeLists();
        chunks.push('<ul>');
        inUnorderedList = true;
      }
      chunks.push(`<li>${inlineMarkdownToHtml(line.slice(2))}</li>`);
      continue;
    }
    if (line.trim() === '') {
      closeLists();
      continue;
    }

    closeLists();
    chunks.push(`<p>${inlineMarkdownToHtml(line)}</p>`);
  }

  closeLists();
  return chunks.join('\n');
}

function buildHtml(markdown) {
  const body = markdownToHtml(markdown);
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="refresh" content="15" />
  <title>Pitch Prep Notes</title>
  <style>
    :root {
      --bg: #f3f6fb;
      --panel: #ffffff;
      --ink: #182230;
      --muted: #5d6b7b;
      --line: #d8e1ec;
      --accent: #005bd1;
      --accent-soft: #eaf2ff;
      --mono-bg: #eef3f9;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 8% 10%, #ffffff, var(--bg));
      color: var(--ink);
      font-family: "Segoe UI", "SF Pro Text", "Avenir Next", sans-serif;
      line-height: 1.55;
      font-size: 18px;
      padding: 28px 16px 80px;
    }
    .wrap {
      max-width: 960px;
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 28px 30px 34px;
      box-shadow: 0 10px 30px rgba(20, 42, 80, 0.08);
    }
    h1, h2, h3 { margin: 0; line-height: 1.25; }
    h1 { font-size: 2rem; margin-bottom: 16px; }
    h2 {
      font-size: 1.32rem;
      margin-top: 24px;
      margin-bottom: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }
    h3 { font-size: 1.05rem; margin-top: 16px; margin-bottom: 8px; color: var(--accent); }
    p { margin: 7px 0 9px; color: var(--ink); }
    ul, ol { margin: 4px 0 12px 24px; padding: 0; }
    li { margin: 5px 0; }
    code {
      background: var(--mono-bg);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 1px 6px;
      font-size: 0.92em;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
    }
    strong { color: #0f1f35; }
    .banner {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 18px;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--accent-soft);
      border: 1px solid #cde0ff;
      color: #0f3678;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      body { font-size: 16px; padding: 12px 8px 42px; }
      .wrap { padding: 16px 14px 22px; border-radius: 12px; }
      h1 { font-size: 1.42rem; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <div class="banner">
      <span>This page auto-refreshes every 15s.</span>
      <span>Source: <code>docs/PITCH-PREP.md</code></span>
    </div>
${body}
  </main>
</body>
</html>
`;
}

function writePitchDoc() {
  const markdown = buildMarkdown();
  const html = buildHtml(markdown);
  const previous = (() => {
    try {
      return readFileSync(outputPath, 'utf8');
    } catch {
      return '';
    }
  })();
  const previousHtml = (() => {
    try {
      return readFileSync(outputHtmlPath, 'utf8');
    } catch {
      return '';
    }
  })();

  if (markdown !== previous) {
    writeFileSync(outputPath, markdown, 'utf8');
    process.stdout.write(`[pitch-prep] updated ${outputPath}\n`);
  }
  if (html !== previousHtml) {
    writeFileSync(outputHtmlPath, html, 'utf8');
    process.stdout.write(`[pitch-prep] updated ${outputHtmlPath}\n`);
  }
  if (markdown === previous && html === previousHtml) {
    process.stdout.write('[pitch-prep] no changes\n');
  } else {
    process.stdout.write('[pitch-prep] refreshed output files\n');
  }
}

writePitchDoc();

if (watchMode) {
  process.stdout.write(`[pitch-prep] watching every ${safeIntervalSeconds}s\n`);
  setInterval(() => {
    writePitchDoc();
  }, safeIntervalSeconds * 1000);
}
